算法
	算法就是兵法
	帮助更好的思考编程的逻辑
	算法可以展现你的思路
	可以弥补python程序员的短板：对底层架构理解偏弱


程序 = 数据结构 + 算法

总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体



平方根算法
	穷举法 138步
	二分法 7步
	牛顿法 2步

常见的数据结构
	线性表
		顺序表
		链表
			单向链表
			双向链表
			循环链表
	散列表
	栈
	队列
	树：
		二叉树
		查找树
		平衡树
		线索
		堆

算法涉及到的内容
	查找
	排序
	递归
	复杂度 ：算法的评估方式。
		时间复杂度
		空间复杂度

计算机的资源瓶颈
	CPU
		操作数
	内存
		数据量（控件）
	IO
		跟内存有关，现在硬件上来了，基本无关了。

算法不依赖语言
对于复杂的算法，高级的客制化的数据结构，不论哪种语言都可以实现。

算法的五大特性
	输入：算法具有0个和多个输入
	输出：算法至少有1个或者多个输出
	有穷性：算法在有限的步骤之后会自动结束，并且在可接受的时间内完成
	确定性：每一步都有确定的意义
	可行性：每一步都是可行的，每一步都能够执行有限次数完成。

穷举法有时候还是可以用的，保底用，能实现功能。

基本运算总数 * 基本运算的单位时间

T:10*n^3

大O表示法
	时间复杂度是衡量算法操作数随着问题规模的变化的一个变化趋势。


最优时间复杂度
	算法完成工作最少需要多少基本工作
最坏时间复杂度
	算法完成工作最多需要多少基本工作，衡量算法用最坏时间复杂度
平均时间复杂度
	算法完成工作平均需要多少基本工作

计算时间复杂度
	基本操作，时间复杂度 认定时间复杂度为O(1)
	顺序结构 ，时间复杂度按加法进行计算
	循环结构，按乘法计算
	分支结构，按最大值计算
	一般只取最高次项，其他次要项可以忽略
	在没有说明的情况下，所有的时间复杂度都是指最坏时间复杂度

空间复杂度
	运行时占用的内存的空间的数目，现在空间成本比较低。

计算机上 log n  指的是对数以2为底数

timeit 
	测试一小段代码python代码的执行速度

基本数据
	保存的是一个数据，不是整个数据，

程序=算法 + 数据结构
数据结构
	解决问题存储的内容
算法
	解决数据问题的方法

线性表：
	顺序表：将元素顺序的存放在一块连续的存储区里，元素间的顺序关系由他们的内存顺序自然表示。
	链表：将元素存放在通过链接构造起来的一系列存储块中


计算中最小存储单元 1 byte
整型：4个存储单元
字符：1个存储单元

顺序表：
	先存放元素，返回存储空间的地址，开辟一个连续的存储空间，存储返回的存储空间的地址

元素存储区扩充
	采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。

扩充的两种策略
	1.每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。

	特点：节省空间，但是扩充操作频繁，操作次数多。

	2.每次扩充容量加倍，如每次扩充增加一倍存储空间。

	特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。


链表：
	在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。

单向链表：
	每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。
	相对于顺序表，链表更节省存储空间，但是找数据更复杂。

	元素域elem用来存放具体的数据。
	链接域next用来存放下一个节点的位置（python中的标识）
	变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点

spark hadoop主要用于电商，而电商主要用java 
淘宝以前使用php  由于并发量不好 后来换成java. 以后做的强了以后，直接改语言 改框架。
pyhton 找的方向为数据分析 和人工智能
php 看不了以后的发展方向，官网直接建议php 程序员转其他的语言。

双向链表：
	一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。

单向循环链表：
	单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点

栈：
	也称堆栈，是一种容器，可以存入数据元素，访问元素，删除元素，它的特点是允许在容器的一段（成为栈顶端指标 top），进行加入数据push 和输出数据（pop）的运算，没有位置的概念，保证任何时候可以访问，删除元素都是此前最后存入的那个元素，确定了一种默认的访问顺序，
	由于只能在一段操作，因此，按照后进先出的原理运作。

	stack()创建一个新栈
	
	class Stack(object):
	    def __init__(self):
	        self.__items = []

	    # self.singleLinkList()
	    def push(self, item):
	        """添加一个新的元素到栈顶"""
	        self.__items.append(item)  # O(1)
	        # self.__items.insert(0,item)  # O(n)

	    def pop(self):
	        """弹出栈顶元素"""
	        return self.__items.pop()

	    def peek(self):
	        """返回底部元素"""
	        return self.__items[-1]

	    def size(self):
	        """返回栈的大小"""
	        return len(self.__items)

	    def is_empty(self):
	        """查看栈是否为空"""
	        return self.__items == []


	每次新申请一个进程的时候，
	MMU负责把虚拟的内存映射到真实的物理内存条上
	用python 写的东西都在堆里面，解释器层面的东西都在用户栈里面


队列：
	是一种先进先出的线性表简称FIFO。允许插入的一段为队尾，允许删除的一端为队头
	队列肯定一端是进，一端是出，复杂度肯定一个是O(1 )一个是O（n）

	双端队列：deque
		一种具有队列和栈的性质的数据结构
		双端队列的元素可以从两端弹出，其限定插入和删除操作在标的两端进行，双端队列可以在对垒任意一段入队和出队。


排序算法是一种能将一串数据依照特定顺序进行排列的一种算法。

排序算法的稳定性
	稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。

冒泡排序：
	比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。遍历之后，最后的元素会是最大的数。
	对除了最后一个元素的剩下的元素，重复以上操作。

	最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）
	最坏时间复杂度：O(n2)
	稳定性：稳定

	def bubble_sort(alist):
	    for j in range(len(alist)-1,0,-1):
	        # j表示每次遍历需要比较的次数，是逐渐减小的
	        for i in range(j):
	            if alist[i] > alist[i+1]:
	                alist[i], alist[i+1] = alist[i+1], alist[i]

选择排序：
	找到最小元素，放到序列的起始位置。
	从剩下元素中找最小元素，然后放到已排序序列的末尾。

	最优时间复杂度：O(n2)
	最坏时间复杂度：O(n2)
	稳定性：不稳定（考虑升序每次选择最大的情况

	def selection_sort(alist):
	    n = len(alist)
	    # 需要进行n-1次选择操作
	    for i in range(n-1):
	        # 记录最小位置
	        min_index = i
	        # 从i+1位置到末尾选择出最小数据
	        for j in range(i+1, n):
	            if alist[j] < alist[min_index]:
	                min_index = j
	        # 如果选择出的数据不在正确位置，进行交换
	        if min_index != i:
	            alist[i], alist[min_index] = alist[min_index], alist[i]

插入排序：
	构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

	最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）
	最坏时间复杂度：O(n2)
	稳定性：稳定

	def insert_sort(alist):
	    # 从第二个位置，即下标为1的元素开始向前插入
	    for i in range(1, len(alist)):
	        # 从第i个元素开始向前比较，如果小于前一个元素，交换位置
	        for j in range(i, 0, -1):
	            if alist[j] < alist[j-1]:
	                alist[j], alist[j-1] = alist[j-1], alist[j]

希尔排序：（插入排序的升级版）
	将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。

	最优时间复杂度：根据步长序列的不同而不同
	最坏时间复杂度：O(n2)
	稳定性：不稳定

	def shell_sort(alist):
	    n = len(alist)
	    # 初始步长
	    gap = n / 2
	    while gap > 0:
	        # 按步长进行插入排序
	        for i in range(gap, n):
	            j = i
	            # 插入排序
	            while j>=gap and alist[j-gap] > alist[j]:
	                alist[j-gap], alist[j] = alist[j], alist[j-gap]
	                j -= gap
	        # 得到新的步长
	        gap = gap / 2

快速排序：
	1.从数列中挑出一个元素，称为"基准"（pivot），
	2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
	3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

	最优时间复杂度：O(nlogn)
	最坏时间复杂度：O(n2)
	稳定性：不稳定

	def quick_sort(alist, start, end):
    """快速排序"""
	    # 递归的退出条件
	    if start >= end:
	       return
	    # 设定起始元素为要寻找位置的基准元素
	    mid = alist[start]
	    # low为序列左边的由左向右移动的游标
	    low = start
	    # high为序列右边的由右向左移动的游标
	    high = end
	    while low < high:
	        # 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动
	        while low < high and alist[high] >= mid:
	            high -= 1
	        # 将high指向的元素放到low的位置上
	        alist[low] = alist[high]
	        # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动
	        while low < high and alist[low] < mid:
	            low += 1
	        # 将low指向的元素放到high的位置上
	        alist[high] = alist[low]
	    # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置
	    # 将基准元素放到该位置
	    alist[low] = mid
	    # 对基准元素左边的子序列进行快速排序
	    quick_sort(alist, start, low-1)
	    # 对基准元素右边的子序列进行快速排序
	    quick_sort(alist, low+1, end)

归并排序：
	将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。

	最优时间复杂度：O(nlogn)
	最坏时间复杂度：O(nlogn)
	稳定性：稳定

	def merge_sort(alist):
	    if len(alist) <= 1:
	        return alist
	    # 二分分解
	    num = len(alist)/2
	    left = merge_sort(alist[:num])
	    right = merge_sort(alist[num:])
	    # 合并
	    return merge(left,right)

	def merge(left, right):
	    '''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''
	    #left与right的下标指针
	    l, r = 0, 0
	    result = []
	    while l<len(left) and r<len(right):
	        if left[l] < right[r]:
	            result.append(left[l])
	            l += 1
	        else:
	            result.append(right[r])
	            r += 1
	    result += left[l:]
	    result += right[r:]
	    return result

	alist = [54,26,93,17,77,31,44,55,20]
	sorted_alist = mergeSort(alist)
	print(sorted_alist)

二分法查找实现：
	最优时间复杂度：O(1)
	最坏时间复杂度：O(logn)

	def binary_search(alist, item):
	    """循环实现二分法查找"""
	    left = 0
	    right = len(alist) - 1

	    while left <= right:
	        mid = (left + right) // 2
	        if item == alist[mid]:
	            return mid
	        elif item < alist[mid]:
	            right = mid - 1
	        else:
	            left = mid + 1


	def b_search(alist, item):
	    """递归实现二分法查找"""
	    if len(alist) == 0:
	        return False
	    else:
	        mid = len(alist) // 2
	        if alist[mid] == item:
	            return mid
	        else:
	            if item < alist[mid]:
	                return b_search(alist[:mid], item)
	            else:
	                return b_search(alist[mid + 1:], item)

树：
	是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>=1）个有限节点组成一个具有层次关系的集合。
	
	特点:
		每个节点有零个或多个子节点；
		没有父节点的节点称为根节点；
		每一个非根节点有且只有一个父节点；
		除了根节点外，每个子节点可以分为多个不相交的子树；

	树的术语
		节点的度：
			一个节点含有的子树的个数称为该节点的度；
		树的度：
			一棵树中，最大的节点的度称为树的度；
		叶节点或终端节点：
			度为零的节点；
		父亲节点或父节点：
			若一个节点含有子节点，则这个节点称为其子节点的父节点；
		孩子节点或子节点：
			一个节点含有的子树的根节点称为该节点的子节点；
		兄弟节点：
			具有相同父节点的节点互称为兄弟节点；
		节点的层次：
			从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
		树的高度或深度：
			树中节点的最大层次；
		堂兄弟节点：
			父节点在同一层的节点互为堂兄弟；
		节点的祖先：
			从根到该节点所经分支上的所有节点；
		子孙：
			以某节点为根的子树中任一节点都称为该节点的子孙。
		森林：
			由m（m>=0）棵互不相交的树的集合称为森林；

	树的种类
		无序树：
			树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；(一般研究的树为有序树)
		有序树：
			树中任意节点的子节点之间有顺序关系，这种树称为有序树；
			二叉树：
				每个节点最多含有两个子树的树称为二叉树；
				完全二叉树：
					对于一颗二叉树，假设其深度为d(d>1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;
				平衡二叉树（AVL树）：
					当且仅当任何节点的两棵子树的高度差不大于1的二叉树；
				排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；
			霍夫曼树（用于信息编码）：
				带权路径最短的二叉树称为哈夫曼树或最优二叉树；
			B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。

	常见的一些树的应用场景
		1.xml，html等，那么编写这些东西的解析器的时候，不可避免用到树
		2.路由协议就是使用了树的算法
		3.mysql数据库索引
			相当于使用了二分法进行查找，使用索引查找数据非常快达到O，
			但是使用索引添加和删除的时候会破坏树的平衡结构，因此要重新生成树，使操作变慢。
		4.文件系统的目录结构
		5.所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构












	欧几里得算法
























